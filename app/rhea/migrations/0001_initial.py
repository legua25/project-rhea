# -*- coding: utf-8 -*-
# Generated by Django 1.9.4 on 2016-03-22 00:47
from __future__ import unicode_literals

import app.rhea.models._programs
import app.rhea.models._schedule
import app.rhea.models._users
from django.conf import settings
import django.core.validators
from django.db import migrations, models
import django.db.models.deletion
import imagekit.models.fields


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='User',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('password', models.CharField(max_length=128, verbose_name='password')),
                ('last_login', models.DateTimeField(blank=True, null=True, verbose_name='last login')),
                ('active', models.BooleanField(default=True, verbose_name='is active')),
                ('user_id', models.CharField(db_index=True, help_text="\n            The user ID, which can be either an enrollment ID in the case of a student or a\n            payroll ID in the case of any other person (instructor or staff member). The\n            user ID is protected by a regular expression validator - only valid IDs as specified\n            by the institution's policies is a valid ID.\n        ", max_length=16, unique=True, validators=[django.core.validators.RegexValidator(regex='^[LA][\\d]+$')], verbose_name='user ID')),
                ('date_registered', models.DateTimeField(auto_now_add=True, help_text='\n            The date in which this user registered. This is kept for historic reasons and is not\n            required by the generator in any way.\n        ', verbose_name='date registered')),
                ('full_name', models.CharField(help_text="\n            The user's full name. Enough space is given to take into account distinct configurations\n            and most foreign names according to the W3C suggestions on the topic of internationalization\n            and name storage.\n        ", max_length=1024, verbose_name='full name')),
                ('picture', imagekit.models.fields.ProcessedImageField(default='users/default/picture.png', help_text='\n            A picture of the user used for profile only. This is not required by the generator in\n            any way.\n        ', upload_to=app.rhea.models._users._upload_to, verbose_name='user picture')),
                ('email_address', models.EmailField(help_text='\n            The institutional email address. This is expected to exist and should be provided by\n            the institution through their own internal processes. This serves as the official means\n            for the system to communicate new schedule selection sessions and to notify any mismatch\n            or results.\n        ', max_length=255, verbose_name='email address')),
            ],
            options={
                'swappable': 'AUTH_USER_MODEL',
                'verbose_name': 'user',
                'verbose_name_plural': 'users',
            },
        ),
        migrations.CreateModel(
            name='AcademicProgram',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('active', models.BooleanField(default=True, verbose_name='is active')),
                ('acronym', models.CharField(db_index=True, help_text='\n\t\t\tAn acronym given to the academic program for identification purposes. Since text searches\n\t\t\tare not gracefully handled by the database, we cannot use this as the primary key, although\n\t\t\tit acts like such.\n\t\t', max_length=8, unique=True, verbose_name='acronym')),
                ('name', models.CharField(help_text="\n\t\t\tThe academic program's user-friendly name, as provided by the institution's program\n\t\t\tportfolio. The name is purely aesthetic and is not used by the generator in any way.\n\t\t", max_length=256, verbose_name='program full name')),
                ('graduate_profile', models.FileField(help_text="\n\t\t\tThis is an *.html file which contains the graduate profile for the program's profile to\n\t\t\tshowcase. If provided, the contents of this file will be processed and rendered along with\n\t\t\tthe program's profile information.\n\t\t", null=True, upload_to=app.rhea.models._programs._upload_to, verbose_name='graduate profile')),
            ],
            options={
                'verbose_name': 'academic program',
                'verbose_name_plural': 'academic programs',
            },
        ),
        migrations.CreateModel(
            name='Course',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('active', models.BooleanField(default=True, verbose_name='is active')),
                ('day', models.PositiveSmallIntegerField(choices=[(0, 'Monday'), (1, 'Tuesday'), (2, 'Wednesday'), (3, 'Thursday'), (4, 'Friday')], help_text="\n\t\t\tThe day of the week in which this course takes place. This model allows us maximum\n\t\t\tlocation flexibility by assigning a single course to a single day on a time period with\n\t\t\tthe according restrictions. This way, we're manipulating a shorter, more concise and\n\t\t\tsparse-friendly version of the schedule hyper-matrix.\n\t\t", verbose_name='day of week')),
                ('time', models.PositiveSmallIntegerField(choices=[(0, '07:00'), (1, '08:30'), (2, '10:00'), (3, '11:30'), (4, '13:00'), (5, '14:30'), (6, '16:00'), (7, '17:30'), (8, '19:00'), (9, '20:30')], help_text='\n\t\t\tThis represents the time slot assigned to this course on a given day of the week. Since\n\t\t\tassignments occur only per day, time slots are also fixed to certain records, according\n\t\t\tto our constraint specifying the duration of all courses from 07:00 to 22:00 at maximum.\n\t\t', verbose_name='time slot')),
                ('date_started', models.DateTimeField(help_text="\n\t\t\tThis sets the date in which the course started. Dates are subject to the institution's\n\t\t\tpolicies regarding academic periods and must be set manually afterwards. Good thing this\n\t\t\tcan be a batch operation if we take into account the final schedules.\n\t\t", null=True, verbose_name='date started')),
                ('date_ended', models.DateTimeField(help_text="\n\t\t\tThis sets the date in which the course officially ended. Dates are subject to the\n\t\t\tinstitution's policies regarding academic periods and must be set manually afterwards.\n\t\t\tGood thing this can be a batch operation if we take into account the final schedules.\n\t\t", null=True, verbose_name='date ended')),
            ],
            options={
                'verbose_name': 'course',
                'verbose_name_plural': 'courses',
            },
        ),
        migrations.CreateModel(
            name='Permission',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('active', models.BooleanField(default=True, verbose_name='is active')),
                ('codename', models.CharField(help_text='\n\t\t\tThe code name given to this permission. This is used by the permission decorators to\n\t\t\tdetermine which permissions should the current user have to be eligible for a certain\n\t\t\tpage or action.\n\t\t', max_length=32, unique=True, verbose_name='permission code name')),
                ('name', models.CharField(default='', help_text='\n\t\t\tA user-friendly name for this permission, to make this selectable from the user\n\t\t\tadministration page.\n\t\t', max_length=64, verbose_name='permission name')),
            ],
            options={
                'verbose_name': 'permission',
                'verbose_name_plural': 'permissions',
            },
        ),
        migrations.CreateModel(
            name='Requirement',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('active', models.BooleanField(default=True, verbose_name='is active')),
            ],
            options={
                'verbose_name': 'subject requirement',
                'verbose_name_plural': 'subject requirements',
            },
        ),
        migrations.CreateModel(
            name='Role',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('active', models.BooleanField(default=True, verbose_name='is active')),
                ('codename', models.CharField(help_text='\n\t\t\tThe code name given to this role. This is used by the permission decorators to determine\n\t\t\twhich role or roles should the current user have to be eligible for a certain page or\n\t\t\taction.\n\t\t', max_length=32, unique=True, verbose_name='role code name')),
                ('name', models.CharField(default='', help_text='\n\t\t\tA user-friendly name for this role, to make this selectable from the user administration\n\t\t\tpage.\n\t\t', max_length=64, verbose_name='role name')),
                ('base', models.ForeignKey(help_text="\n\t\t\tIf provided, this specifies a base role from which to inherit permissions. This essentially\n\t\t\tcreates a permission chain through which we must go to check for permissions. If the current\n\t\t\trole doesn't define the permission but it has a base role, the base role is recursively\n\t\t\tqueried until either the permission is found or all possibilities are exhausted.\n\t\t", null=True, on_delete=django.db.models.deletion.CASCADE, related_name='subroles', to='rhea.Role', verbose_name='base role')),
                ('permissions', models.ManyToManyField(help_text='\n\t\t\tA list of all permission tokens this role is entitled to. Roles also inherit permissions\n\t\t\tfrom their parent roles (if any).\n\t\t', related_name='roles', to='rhea.Permission', verbose_name='role permissions')),
            ],
            options={
                'verbose_name': 'user role',
                'verbose_name_plural': 'user roles',
            },
        ),
        migrations.CreateModel(
            name='ScheduleFile',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('active', models.BooleanField(default=True, verbose_name='is active')),
                ('type', models.PositiveSmallIntegerField(choices=[(0, 'Student academic schedule'), (1, 'Instructor academic schedule'), (2, 'Instructor work preference schedule')], help_text="\n\t\t\tThe type of schedule we're storing. We use this to determine where should we show the\n\t\t\tschedule, how should we name it and to whom should we relate it to, since students have\n\t\t\tone schedule and instructors have two.\n\t\t", verbose_name='schedule type')),
                ('data', models.FileField(help_text="\n\t\t\tThe actual schedule, as a *.bson file. We chose this representation because we must store\n\t\t\ta set of sparse data representing time slots, pointers to instructors and pointers to\n\t\t\tcourses. Storing in the RDBMS, although it may seem as a nice option, will cause a lot of\n\t\t\twasted resources per query where we need a free-form approach for data which will tend not\n\t\t\tto mutate further as time goes by. Note that, per scope, we're disregarding dropping out\n\t\t\tof courses as a valid action and we disallow it for simplicity.\n\t\t", upload_to=app.rhea.models._schedule._upload_to, verbose_name='schedule data file')),
                ('expiry', models.DateField(help_text="\n\t\t\tThe date in which this schedule was created. Since we use an expiry system with schedules\n\t\t\tto deallocate them when done being useful, we must record the expiry date to compare it\n\t\t\twith today's date to check if the schedule is still valid.\n\t\t", verbose_name='expiry date')),
            ],
            options={
                'verbose_name': 'academic schedule',
                'verbose_name_plural': 'academic schedules',
            },
        ),
        migrations.CreateModel(
            name='Specialty',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('active', models.BooleanField(default=True, verbose_name='is active')),
                ('confidence', models.FloatField(default=0.5, help_text='\n\t\t\tThe confidence factor is a number from 0.0 to 1.0 inclusive which allows instructors\n\t\t\tto rank subjects based on their particular specialties. Confidence factors are personal\n\t\t\tand involve elements such as experience in the particular subject, personal preference\n\t\t\tfor the given subject and availability. 0.0 implies "would not instruct", whereas 1.0\n\t\t\timplies "will definitely instruct".\n\t\t', verbose_name='confidence factor')),
            ],
            options={
                'verbose_name': 'specialty subject',
                'verbose_name_plural': 'specialty subjects',
            },
        ),
        migrations.CreateModel(
            name='Subject',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('active', models.BooleanField(default=True, verbose_name='is active')),
                ('code', models.CharField(help_text='\n\t\t\tA subject code provided by the institution to uniquely identify a subject. This is used\n\t\t\tprimarily to query for dependencies or followup candidates, if any. As per the project\'s\n\t\t\tscope, we are not considering "variants" nor equivalencies in this design.\n\t\t', max_length=16, unique=True, verbose_name='subject code')),
                ('name', models.CharField(help_text="\n\t\t\tThis is the user-friendly version of this subject, used only by the program's profile to\n\t\t\tshowcase the composing subjects and their dependencies.\n\t\t", max_length=256, verbose_name='subject name')),
                ('hours', models.PositiveSmallIntegerField(default=1, help_text='\n\t\t\tThis is a measurement of the expected time, in hours per week, a course for this subject\n\t\t\tshould use. The provided value is divided by 1.5 (since our blocks are assumed to be of\n\t\t\t1.5 hours length). This is used to determine the most probable arrangement for the course\n\t\t\tby the generator.\n\t\t', verbose_name='hours per week')),
            ],
            options={
                'verbose_name': 'subject',
                'verbose_name_plural': 'subjects',
            },
        ),
        migrations.CreateModel(
            name='Instructor',
            fields=[
                ('user_ptr', models.OneToOneField(auto_created=True, on_delete=django.db.models.deletion.CASCADE, parent_link=True, primary_key=True, serialize=False, to=settings.AUTH_USER_MODEL)),
                ('course_schedule', models.OneToOneField(help_text="\n\t\t\tThis schedule is the current academic period's schedule for the instructor. This\n\t\t\tspecifies the courses the instructor should provide and when should these be given.\n\t\t\tSince it is tied to the current academic period, this schedule has an expiry date.\n\t\t", null=True, on_delete=django.db.models.deletion.CASCADE, related_name='instructor', to='rhea.ScheduleFile', verbose_name='current course schedule')),
            ],
            options={
                'verbose_name': 'class instructor',
                'verbose_name_plural': 'class instructors',
            },
            bases=('rhea.user',),
        ),
        migrations.CreateModel(
            name='Student',
            fields=[
                ('user_ptr', models.OneToOneField(auto_created=True, on_delete=django.db.models.deletion.CASCADE, parent_link=True, primary_key=True, serialize=False, to=settings.AUTH_USER_MODEL)),
                ('course_schedule', models.OneToOneField(help_text="\n            This schedule is the current academic period's schedule for the instructor. This\n            specifies the courses the student should take and when should these be taken.\n            Since it is tied to the current academic period, this schedule has an expiry date.\n        ", on_delete=django.db.models.deletion.CASCADE, related_name='student', to='rhea.ScheduleFile', verbose_name='current course schedule')),
                ('program', models.ForeignKey(help_text='\n            The current academic program for this student. Note that changes in the academic\n            program are not considered for this development, but should imply a revalidation\n            analysis on undertaken subjects to correctly position the new subject pointers to\n            their adequate positions prior to making this instance usable again.\n        ', on_delete=django.db.models.deletion.CASCADE, related_name='students', to='rhea.AcademicProgram', verbose_name='academic program')),
            ],
            options={
                'verbose_name': 'student',
                'verbose_name_plural': 'students',
            },
            bases=('rhea.user',),
        ),
        migrations.AddField(
            model_name='specialty',
            name='subject',
            field=models.ForeignKey(help_text='\n\t\t\tA pointer to the subject to which the instructor has a specialty on.\n\t\t', on_delete=django.db.models.deletion.CASCADE, related_name='+', to='rhea.Subject', verbose_name='specialty subject'),
        ),
        migrations.AddField(
            model_name='requirement',
            name='dependency',
            field=models.ForeignKey(help_text='\n\t        A pointer to a subject that is required by the dependent - this stands for the backwards\n\t        side of the relationship and allows for ancestral navigation in the graph.\n\t    ', null=True, on_delete=django.db.models.deletion.CASCADE, related_name='+', to='rhea.Subject', verbose_name='dependency'),
        ),
        migrations.AddField(
            model_name='requirement',
            name='dependent',
            field=models.ForeignKey(help_text='\n\t        A pointer to a subject that requires the dependency - this stands for the forward side of\n\t        the relationship and allows for candidate estimation and progress tracking given a starting\n\t        set.\n\t    ', null=True, on_delete=django.db.models.deletion.CASCADE, related_name='+', to='rhea.Subject', verbose_name='dependent'),
        ),
        migrations.AddField(
            model_name='requirement',
            name='program',
            field=models.ForeignKey(help_text='\n\t\t\tThe academic program this requirement belongs to. Requirements act as graph edges for the\n\t\t\tstudy plan\'s graph - they connect subjects with subjects through a "is required" relationship.\n\t\t\tKeeping the relationship separate from the subjects allows recycling subjects for different\n\t\t\tacademic programs.\n\t\t', on_delete=django.db.models.deletion.CASCADE, related_name='requirements', to='rhea.AcademicProgram', verbose_name='academic program'),
        ),
        migrations.AddField(
            model_name='course',
            name='subject',
            field=models.ForeignKey(help_text='\n\t\t\tThe subject of the lecture series. This is not connected to specific requirements since\n\t\t\tthe subject may be present for more than one academic program and thus would create a\n\t\t\thumongous amount of data duplication which is avoidable.\n\t\t', on_delete=django.db.models.deletion.CASCADE, related_name='courses', to='rhea.Subject', verbose_name='lecture subject'),
        ),
        migrations.AddField(
            model_name='user',
            name='permissions',
            field=models.ManyToManyField(help_text="\n            User-wise permissions which can be added or revoked individually. This does not affect the\n            structure of the role's permissions and is only provided for fine-tuning permissions for\n            specific users, such as superusers or specific staff members who require additional\n            privileges with respect to their role.\n        ", related_name='_user_permissions_+', to='rhea.Permission', verbose_name='user-specific permissions'),
        ),
        migrations.AddField(
            model_name='user',
            name='role',
            field=models.ForeignKey(help_text='\n            The role, permission-wise, this user has on the system. The role of the user is independent\n            of their user type in order to allow for flexible scenarios, such as instructors belonging\n            to staff as well or students who work on the platform for any given reason.\n        ', on_delete=django.db.models.deletion.CASCADE, related_name='users', to='rhea.Role', verbose_name='user role'),
        ),
        migrations.AddField(
            model_name='student',
            name='subjects',
            field=models.ManyToManyField(help_text="\n            This is a list of pointers to subjects in the academic program's requirements tree,\n            or course plan. The list points to current subjects only - candidates are calculated\n            on demand by the schedule generator.\n        ", related_name='_student_subjects_+', to='rhea.Requirement', verbose_name='currently-coursing subjects'),
        ),
        migrations.AddField(
            model_name='specialty',
            name='instructor',
            field=models.ForeignKey(help_text='\n\t\t\tThe instructor who features a specialty in the given subject. Specialties are specified\n\t\t\tand ranked by the instructor\n\t\t', on_delete=django.db.models.deletion.CASCADE, related_name='specialties', to='rhea.Instructor', verbose_name='instructor'),
        ),
        migrations.AddField(
            model_name='instructor',
            name='subjects',
            field=models.ManyToManyField(help_text='\n            This is a list of pointers to subjects which the instructor can teach. These are\n            considered the instructor\'s "specialty subjects" and are ranked according to\n            confidence: a number from 0.0 to 1.0 inclusive which allows instructors to rank\n            subjects based on their particular specialties. Ties may exist - this is only a\n            hint on which subjects to consider first.\n        ', related_name='instructors', through='rhea.Specialty', to='rhea.Subject', verbose_name='subjects that can be instructed'),
        ),
        migrations.AddField(
            model_name='instructor',
            name='work_schedule',
            field=models.OneToOneField(help_text='\n\t\t\tThis schedule serves as a "probability matrix" which gets merged with the course\'s\n\t\t\tin order to determine possible slots in which the course could be fitted into.\n\t\t', null=True, on_delete=django.db.models.deletion.CASCADE, related_name='user', to='rhea.ScheduleFile', verbose_name='work schedule'),
        ),
        migrations.AddField(
            model_name='course',
            name='instructor',
            field=models.ForeignKey(help_text='\n\t\t\tCourses is a list of all courses, past and present, which the instructor provided.\n\t\t\tThis field is provided for historic reasons and is not actually used by the generator\n\t\t\tto calculate the new schedules.\n\t\t', on_delete=django.db.models.deletion.CASCADE, related_name='courses', to='rhea.Instructor', verbose_name='instructor'),
        ),
        migrations.AddField(
            model_name='course',
            name='students',
            field=models.ManyToManyField(help_text='\n            Courses is a list of all courses, past and present, which the student participated in.\n            This field is provided for historic reasons and is not actually used by the generator\n            to calculate the new schedules.\n        ', related_name='courses', to='rhea.Student', verbose_name='students'),
        ),
    ]
